## 里氏替换原则
+ 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，是的以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用父类的地方必须能透明地使用其子类的对象。
+ 在使用继承是，在子类中尽量不要重写父类的方法
+ 里氏替换原则告诉我们，继承实际上让两个类耦合性增加了，在适当的情况下，可以通过聚合，组合，依赖来解决问题


里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：

+ 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
+ 子类中可以增加自己特有的方法。
+ 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
+ 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

案例：
```java
class A {

    //返回两个数的差
    public int func1(int a, int b) {
        return a - b;
    }
}


class B extends A {
    // 类B可能无意重写了父类方法，造成原有功能出现错误
    public int func1(int a, int b) {
        return a + b;
    }

}
```
很明显上述代码不遵循里氏替换原则，B类继承A类，并重写了A类的func1方法，这样在调用时对A来说子类的func1方法不再透明，而造成结果的错误

此时我们需要改进这样的代码，如下：
```java
// 创建一个更加基础的类
class Base {

}

class A extends Base {

    //返回两个数的差
    public int func1(int a, int b) {
        return a - b;
    }
}


class B extends Base {
    // 如果B仍然想使用A的方法，使用组合关系
    private A a = new A();

    public int func1(int a, int b) {
        return a + b;
    }


    public int func2(int a, int b) {
        return this.a.func1(a, b);
    }

}
```
我们选择创建一个功能更为基础的类Base，让A、B分别继承Base，这样AB不存在继承关系在调用时，函数的功能就很明确了，若B类还想使用到A类的方法，可以通过聚合、组合、依赖方法来实现